You, as a Senior PHP developer, I want you to carefully read docs/plan/sdk-development-plan.md and deeply analyze current implementation status. After than, continue implementation with phase 5.

**IMPORTANT** I will release this repo on github, as a open source library. So, you **HAVE TO** follow open source library development best practices also.

Think deeply about how you'll do this and plan a solution that fully respects the following principles.

**YOU MUST** follow instructions described below.

### MANDATORY Process to Follow:

#### 1. Discovery Phase (DO THIS FIRST!)
- **Read and analyze** the existing implementation
- **Understand** patterns from existing code

#### 2. Self-Review Checklist (AFTER EACH COMPONENT)
Review your code against:

- [ ] Is this code self-documenting?
- [ ] Have I eliminated ALL duplication?
- [ ] Does each class have a single responsibility?
- [ ] Are all dependencies injected via constructor?
- [ ] Have I used appropriate design patterns?
- [ ] Is this the simplest solution that works (KISS)?
- [ ] Is this the required or necessary (YAGNI)?
- [ ] Is the code PSR-compliant?

### What NOT to Do:
1. ❌ Don't skip the discovery phase
2. ❌ Don't rush through without self-review
3. ❌ Don't make changes without understanding existing patterns

### What TO Do:
1. ✅ Thoroughly analyze existing code FIRST
2. ✅ Review after EACH component
3. ✅ Work incrementally with small commits

## Definition of Done

- [ ] All remaining tasks completed
- [ ] Self-review checklist completed

## Technical Constraints

### Architectural Principles

You **MUST** follow these principles:

- **SOLID, DRY, KISS, YAGNI, Clean Code** principles
- **ALWAYS** follow PSR standards
- Proper **Separation of concerns**
- **DIP** is crucial, use dependency injection. Always depend on abstractions for external systems
- **Design by Contract**, **Fail-Fast**, **Defensive Programming**.
- **Law of Demeter, composition over inheritance**
- Self-documenting, clean code practices
- Use appropriate **design patterns** whenever possible. For example, use the strategy design pattern instead of complex switch statements, etc
- **NO OVER-ENGINEERING**
- **NO WORK-AROUND** solutions or implementations
- **NEVER, EVER** Code duplication
- **Low Coupling & High Cohesion**
- **Information Hiding / Encapsulation**, **Immutability**.
- **Error Handling**: Rich domain errors, retry/backoff, idempotency.
- **Concurrency Safety**: Race conditions, deadlock, lock-free, atomicity.

think deeply with sequential mcp
